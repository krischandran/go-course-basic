<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Слайсы в Go — Введение</title>

    <!-- Telegram Web App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
          integrity="sha512-Jk4AqjWsdSzSWCSuQTfYRIF84Rq/eV0G2+tu07byYwHcbTGfdmLrHjUSwvzp5HvbiqK4ibmNwdcG49Y5RGYPTg=="
          crossorigin="anonymous"
          referrerpolicy="no-referrer">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"
            integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"
            integrity="sha512-5fby2A9Cgu49xHMsMCsKPBRMIlKPVXO/WBYvpWpQJpJH3lFJ4oEiJBWqVIXqXk6hqPoHpsBwQqEYbLhnL8IWCg=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"></script>

    <style>
        :root {
            --bg-primary: #070709;
            --bg-secondary: #0d0d0f;
            --bg-tertiary: #111113;
            --text-primary: #ffffff;
            --text-secondary: #dddddd;
            --text-muted: #a7a7a7;
            --border-color: #1a1a1c;
            --border-light: #363636;
            --accent-green: #2af16b;
            --accent-orange: #f1a12a;

        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 16px;
            line-height: 1.65;
            color: var(--text-primary);
            background-color: var(--bg-primary);
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            /* Safe area for notch devices */
            padding: 0 env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        /* Main content - no sidebar, no fixed header */
        main {
            max-width: 100%;
            padding: 16px;
            padding-bottom: calc(24px + env(safe-area-inset-bottom));
        }

        /* Module badge */
        .module-badge {
            display: inline-block;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-green);
            background: rgba(42, 241, 107, 0.1);
            padding: 4px 10px;
            border-radius: 4px;
            margin-bottom: 12px;
        }

        h1 {
            font-size: 24px;
            font-weight: 700;
            letter-spacing: -0.02em;
            line-height: 1.2;
            margin-bottom: 12px;
        }

        .lead {
            font-size: 16px;
            line-height: 1.6;
            color: var(--text-secondary);
            margin-bottom: 32px;
        }

        h2 {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin: 40px 0 20px;
            scroll-margin-top: 20px;
        }
        h2::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--accent-green);
            border-radius: 2px;
            flex-shrink: 0;
        }

        h3 {
            font-size: 18px;
            font-weight: 600;
            letter-spacing: -0.01em;
            color: var(--text-primary);
            margin: 24px 0 12px;
        }

        p {
            font-size: 15px;
            line-height: 1.7;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        p strong { color: var(--text-primary); font-weight: 600; }

        ul, ol {
            margin: 0 0 16px 20px;
            color: var(--text-secondary);
        }
        li {
            margin-bottom: 6px;
            line-height: 1.6;
            font-size: 15px;
        }

        code {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 13px;
            color: var(--accent-green);
        }

        .code-block {
            margin: 20px 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }
        .code-lang {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
        }
        .copy-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .copy-btn:active {
            background: var(--bg-tertiary);
        }
        .copy-btn.copied {
            border-color: var(--accent-green);
            background: rgba(42, 241, 107, 0.1);
            color: var(--accent-green);
        }
        .code-block pre {
            margin: 0;
            padding: 16px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        .code-block code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            background: transparent;
            padding: 0;
            color: inherit;
        }

        .alert {
            margin: 24px 0;
            padding: 16px 16px 16px 44px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            position: relative;
        }
        .alert-icon {
            position: absolute;
            left: 14px;
            top: 16px;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 11px;
            font-weight: 700;
        }
        .alert-important .alert-icon {
            background: rgba(241, 161, 42, 0.15);
            color: var(--accent-orange);
        }
        .alert-tip .alert-icon {
            background: rgba(42, 241, 107, 0.15);
            color: var(--accent-green);
        }
        .alert p {
            margin: 0;
            font-size: 14px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
            display: block;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        thead, tbody, tr {
            display: table;
            width: 100%;
            table-layout: fixed;
        }
        th {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            background: var(--bg-secondary);
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        td {
            padding: 12px;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        td code {
            background: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
        }

        .info-box {
            margin: 20px 0;
            padding: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            border-left: 3px solid var(--accent-green);
        }
        .info-box .info-row {
            padding: 6px 0;
            color: var(--text-secondary);
            font-size: 14px;
        }
        .info-box .info-row:not(:last-child) {
            border-bottom: 1px solid var(--border-color);
        }

        .flow-diagram {
            margin: 20px 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }
        .flow-diagram svg {
            display: block;
            width: 100%;
            height: auto;
        }

        .card {
            margin: 16px 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }
        .card-head {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }
        .card-num {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 4px;
        }
        .question-card .card-num {
            background: linear-gradient(135deg, rgba(42, 241, 107, 0.2), rgba(42, 241, 107, 0.05));
            color: var(--accent-green);
        }
        .task-card .card-num {
            background: linear-gradient(135deg, rgba(241, 161, 42, 0.2), rgba(241, 161, 42, 0.05));
            color: var(--accent-orange);
        }
        .card-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }
        .card-body {
            padding: 16px;
        }
        .card-body p { margin-bottom: 10px; }
        .card-body p:last-child { margin-bottom: 0; }

        .cards {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        details {
            margin-top: 12px;
        }
        details summary {
            cursor: pointer;
            color: var(--accent-green);
            font-size: 13px;
            font-weight: 500;
            padding: 8px 0;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 6px;
            -webkit-tap-highlight-color: transparent;
        }
        details summary::before {
            content: '>';
            font-size: 12px;
            transition: transform 0.2s;
        }
        details[open] summary::before {
            transform: rotate(90deg);
        }
        details summary::-webkit-details-marker { display: none; }
        .answer, .solution {
            margin-top: 10px;
            padding: 12px;
            background: rgba(42, 241, 107, 0.03);
            border-radius: 6px;
            border-left: 2px solid var(--accent-green);
        }
        .answer p, .solution p {
            font-size: 14px;
            color: var(--text-secondary);
        }
        .solution {
            background: rgba(241, 161, 42, 0.04);
            border-left-color: var(--accent-orange);
        }

        .summary-box {
            margin: 28px 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(42, 241, 107, 0.08) 0%, rgba(42, 241, 107, 0.02) 100%);
            border: 1px solid rgba(42, 241, 107, 0.2);
            border-radius: 12px;
        }
        .summary-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        .summary-badge {
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 3px 8px;
            background: var(--accent-green);
            color: var(--bg-primary);
            border-radius: 4px;
        }
        .summary-title {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .summary-formula {
            background: var(--bg-primary);
            padding: 12px 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 16px;
            border-radius: 6px;
            border-left: 2px solid var(--accent-green);
        }
        .summary-list {
            margin: 0;
            padding-left: 18px;
        }
        .summary-list li {
            color: var(--text-secondary);
            margin-bottom: 6px;
            font-size: 14px;
        }

        blockquote {
            margin: 20px 0;
            padding: 16px;
            background: linear-gradient(90deg, rgba(42, 241, 107, 0.06) 0%, transparent 100%);
            border-left: 2px solid var(--accent-green);
            border-radius: 0 6px 6px 0;
        }
        blockquote p {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            margin: 0;
        }

        hr {
            border: none;
            height: 1px;
            background: var(--border-color);
            margin: 32px 0;
        }

        /* Navigation footer */
        .nav-footer {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 40px;
            padding-top: 24px;
            border-top: 1px solid var(--border-color);
        }
        .nav-link {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            text-decoration: none;
            -webkit-tap-highlight-color: transparent;
        }
        .nav-link:active {
            background: var(--bg-tertiary);
        }
        .nav-link.next {
            justify-content: flex-end;
            text-align: right;
        }
        .nav-arrow {
            font-size: 18px;
            color: var(--accent-green);
        }
        .nav-label {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 2px;
        }
        .nav-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
        }
    </style>
</head>
<body>

<main>
    <div class="module-badge">Слайсы / Урок 1</div>

    <h1>Слайсы в Go: Введение</h1>
    <p class="lead">Разберём внутреннее устройство слайсов, типичные ловушки на собеседованиях и научимся избегать утечек памяти.</p>

    <h2 id="interviews">Что спрашивают на собеседованиях</h2>
    <p>На собеседованиях по слайсам <strong>дают задачи, а не теорию</strong>. Единственный теоретический вопрос:</p>
    <blockquote><p>"Что такое слайс?"</p></blockquote>
    <p>Но чтобы решать задачи, нужно глубоко понимать <strong>как слайс устроен изнутри</strong>.</p>

    <hr>

    <h2 id="array-vs-slice">Массив vs Слайс</h2>

    <h3>Массив: фиксированный блок памяти</h3>
    <p>Массив в Go — это <strong>непрерывная область памяти фиксированного размера</strong>:</p>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">var arr [5]int  // Ровно 5 элементов, ни больше, ни меньше</code></pre>
    </div>

    <div class="code-block">
        <div class="code-header"><span class="code-lang">Schema</span></div>
        <pre><code>Массив [5]int в памяти:
┌─────┬─────┬─────┬─────┬─────┐
│  0  │  0  │  0  │  0  │  0  │  ← 5 * 8 = 40 байт (int = 8 байт)
└─────┴─────┴─────┴─────┴─────┘
  [0]   [1]   [2]   [3]   [4]</code></pre>
    </div>

    <h3>Проблема массивов</h3>
    <p><strong>1. Размер — часть типа.</strong> <code>[3]int</code> и <code>[5]int</code> — это <strong>разные типы</strong>!</p>
    <p><strong>2. Нельзя изменить размер.</strong> Массив из 5 элементов всегда будет из 5 элементов.</p>
    <p><strong>3. Передача по значению.</strong> Когда передаёшь массив в функцию — копируются <strong>все данные</strong>.</p>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">func processArray(arr [1000000]int) {  // Копируется 8MB каждый вызов!
    // ...
}

// Не скомпилируется — разные типы!
var a [3]int
var b [5]int
a = b  // cannot use b (variable of type [5]int) as [3]int</code></pre>
    </div>

    <h3>Слайс: гибкая обёртка над массивом</h3>
    <p>Слайс решает все эти проблемы. Это <strong>структура-обёртка</strong>, которая указывает на массив:</p>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">var s []int  // Слайс — размер не указан
s = append(s, 1, 2, 3)  // Может расти
s = append(s, 4, 5)     // И ещё расти</code></pre>
    </div>

    <table>
        <thead><tr><th>Критерий</th><th>Массив</th><th>Слайс</th></tr></thead>
        <tbody>
            <tr><td>Размер</td><td>Фиксированный</td><td>Динамический</td></tr>
            <tr><td>Синтаксис</td><td><code>[5]int</code></td><td><code>[]int</code></td></tr>
            <tr><td>Передача</td><td>Копируется целиком</td><td>24 байта</td></tr>
            <tr><td>Расширение</td><td>Нет</td><td><code>append</code></td></tr>
        </tbody>
    </table>

    <div class="alert alert-important">
        <div class="alert-icon">!</div>
        <p>В реальном коде ты почти всегда будешь использовать слайсы. Массивы — низкоуровневая деталь.</p>
    </div>

    <hr>

    <h2 id="structure">Структура слайса: 3 поля</h2>

    <p>Слайс — это структура из <strong>трёх полей</strong>. Понимание этого — ключ ко всем задачам на собеседованиях.</p>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">// Внутренняя структура слайса (псевдокод)
type slice struct {
    ptr *array  // указатель на underlying array
    len int     // текущая длина
    cap int     // вместимость (capacity)
}</code></pre>
    </div>

    <h3>Memory Layout</h3>

    <div class="code-block">
        <div class="code-header"><span class="code-lang">Schema</span></div>
        <pre><code>Slice Header (24 байта):       Underlying Array:
┌─────────────────────────┐    ┌─────┬─────┬─────┐
│ ptr ────────────────────┼───►│  1  │  2  │  3  │
├─────────────────────────┤    └─────┴─────┴─────┘
│ len = 3                 │      [0]   [1]   [2]
├─────────────────────────┤
│ cap = 3                 │
└─────────────────────────┘</code></pre>
    </div>

    <table>
        <thead><tr><th>Поле</th><th>Размер</th><th>Описание</th></tr></thead>
        <tbody>
            <tr><td><strong>ptr</strong></td><td>8 байт</td><td>Указатель на первый элемент</td></tr>
            <tr><td><strong>len</strong></td><td>8 байт</td><td>Текущая длина</td></tr>
            <tr><td><strong>cap</strong></td><td>8 байт</td><td>Вместимость без реаллокации</td></tr>
        </tbody>
    </table>

    <h3>Почему cap важен?</h3>

    <p>Capacity определяет, когда нужна <strong>реаллокация</strong> (выделение нового массива):</p>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">s := make([]int, 3, 3)  // len=3, cap=3
s = append(s, 4)        // len станет 4, но cap=3!
// Go выделит НОВЫЙ массив, скопирует данные</code></pre>
    </div>

    <div class="alert alert-tip">
        <div class="alert-icon">i</div>
        <p>Если знаешь примерный размер — <strong>pre-allocate</strong> с помощью <code>make([]T, 0, expectedSize)</code>. Это избежит множества реаллокаций.</p>
    </div>

    <hr>

    <h2 id="reference-type">Почему слайс "ссылочный тип"</h2>

    <p>Это <strong>самая важная</strong> концепция для понимания слайсов. Разберём детально.</p>

    <h3>Что копируется при присваивании?</h3>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">a := []int{1, 2, 3}
b := a  // Что скопировалось?</code></pre>
    </div>

    <p><strong>Копируется только header (24 байта):</strong></p>

    <div class="code-block">
        <div class="code-header"><span class="code-lang">Schema</span></div>
        <pre><code>a (header):                   Underlying Array:
┌─────────────────┐           ┌─────┬─────┬─────┐
│ ptr ────────────┼──────────►│  1  │  2  │  3  │
│ len = 3         │           └─────┴─────┴─────┘
│ cap = 3         │                    ▲
└─────────────────┘                    │
                                       │
b (header):                            │
┌─────────────────┐                    │
│ ptr ────────────┼────────────────────┘
│ len = 3         │   ← НОВЫЙ header, но ТОТ ЖЕ массив!
│ cap = 3         │
└─────────────────┘</code></pre>
    </div>

    <p><strong>a и b указывают на ОДИН массив в памяти!</strong></p>

    <h3>Что это означает на практике?</h3>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">a := []int{1, 2, 3}
b := a
b[0] = 999

fmt.Println(a)  // [999 2 3] — изменился!
fmt.Println(b)  // [999 2 3]</code></pre>
    </div>

    <h3>Сравни с массивом (по значению)</h3>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">a := [3]int{1, 2, 3}  // массив, не слайс!
b := a                 // копируются ВСЕ данные
b[0] = 999

fmt.Println(a)  // [1 2 3] — НЕ изменился
fmt.Println(b)  // [999 2 3]</code></pre>
    </div>

    <div class="alert alert-important">
        <div class="alert-icon">!</div>
        <p>Слайс — это <strong>"окно" в массив</strong>. Несколько слайсов могут смотреть в один массив. Изменения через любой из них видны всем.</p>
    </div>

    <hr>

    <h2 id="traps">Типичные ловушки</h2>

    <h3 id="trap-1">Ловушка 1: Передача слайса в функцию</h3>
    <p>Функция получает <strong>копию header</strong>, но ptr указывает на тот же массив:</p>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">func modify(s []int) {
    s[0] = 999  // меняем общий массив!
}

func main() {
    a := []int{1, 2, 3}
    modify(a)
    fmt.Println(a)  // [999 2 3] — изменился!
}</code></pre>
    </div>

    <div class="code-block">
        <div class="code-header"><span class="code-lang">Schema</span></div>
        <pre><code>main():                          modify() получает копию header:
┌─────────────────┐             ┌─────────────────┐
│ ptr ────────────┼────────┐    │ ptr ────────────┼──────┐
│ len = 3         │        │    │ len = 3         │      │
│ cap = 3         │        │    │ cap = 3         │      │
└─────────────────┘        │    └─────────────────┘      │
                           ▼                              ▼
                    ┌─────┬─────┬─────┐
                    │  1  │  2  │  3  │  ← ОДИН массив!
                    └─────┴─────┴─────┘</code></pre>
    </div>

    <h3 id="trap-2">Ловушка 2: append может создать НОВЫЙ массив</h3>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">func addElement(s []int) {
    s = append(s, 4)  // что произойдёт?
    s[0] = 999
}

func main() {
    a := []int{1, 2, 3}  // len=3, cap=3
    addElement(a)
    fmt.Println(a)  // [1 2 3] — НЕ изменился!
}</code></pre>
    </div>

    <p><strong>Что произошло?</strong></p>
    <p>1. <code>a</code> имеет len=3, cap=3 (нет места для нового элемента)</p>
    <p>2. <code>append</code> выделил <strong>новый массив</strong> с большей capacity</p>
    <p>3. <code>s</code> теперь указывает на новый массив</p>
    <p>4. <code>s[0] = 999</code> меняет новый массив, не <code>a</code></p>

    <div class="alert alert-tip">
        <div class="alert-icon">i</div>
        <p>Если функция делает <code>append</code> и вы хотите видеть изменения — <strong>возвращайте новый слайс</strong> или передавайте <code>*[]int</code>.</p>
    </div>

    <h3 id="trap-3">Ловушка 3: Утечка памяти</h3>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">// Плохо: весь массив остаётся в памяти
func getFirst10(filename string) []byte {
    data, _ := os.ReadFile(filename)  // читает файл 100MB
    return data[:10]  // возвращаем "окно" в 100MB массив
}</code></pre>
    </div>

    <div class="code-block">
        <div class="code-header"><span class="code-lang">Schema</span></div>
        <pre><code>Возвращённый слайс:          Underlying Array (100MB):
┌─────────────────┐          ┌─────┬─────┬──...──┬─────┐
│ ptr ────────────┼─────────►│ ... │ ... │  ...  │ ... │
│ len = 10        │          └─────┴─────┴──...──┴─────┘
│ cap = 100000000 │          ↑                         ↑
└─────────────────┘          используется     не используется,
                             10 байт          но живёт в памяти!</code></pre>
    </div>

    <p><strong>Исправление — явное копирование:</strong></p>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">// Хорошо: копируем только нужные данные
func getFirst10(filename string) []byte {
    data, _ := os.ReadFile(filename)
    result := make([]byte, 10)
    copy(result, data[:10])
    return result  // новый массив на 10 байт
}</code></pre>
    </div>

    <h3 id="trap-4">Ловушка 4: Reslicing создаёт alias</h3>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">a := []int{1, 2, 3, 4, 5}
b := a[1:3]  // b = [2, 3]
b[0] = 999

fmt.Println(a)  // [1 999 3 4 5] — a изменился!</code></pre>
    </div>

    <div class="code-block">
        <div class="code-header"><span class="code-lang">Schema</span></div>
        <pre><code>a:                              Underlying Array:
┌─────────────────┐            ┌─────┬─────┬─────┬─────┬─────┐
│ ptr ────────────┼───────────►│  1  │  2  │  3  │  4  │  5  │
│ len = 5         │            └─────┴──▲──┴─────┴─────┴─────┘
│ cap = 5         │                     │
└─────────────────┘                     │
                                        │
b (a[1:3]):                             │
┌─────────────────┐                     │
│ ptr ────────────┼─────────────────────┘
│ len = 2         │   b[0] это a[1]!
│ cap = 4         │   (cap = 5-1 = 4, от индекса 1 до конца)
└─────────────────┘</code></pre>
    </div>

    <p><strong>Как избежать?</strong></p>

    <div class="code-block">
        <div class="code-header">
            <span class="code-lang">Go</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><code class="language-go">// Явное копирование
a := []int{1, 2, 3, 4, 5}
b := make([]int, 2)
copy(b, a[1:3])
b[0] = 999
fmt.Println(a)  // [1 2 3 4 5] — a НЕ изменился</code></pre>
    </div>

    <hr>

    <h2 id="mechanics">3 механики для решения задач</h2>

    <div class="alert alert-tip">
        <div class="alert-icon">i</div>
        <p>Запомни <strong>LCA</strong>: <strong>L</strong>en/cap, <strong>C</strong>opy-on-append, <strong>A</strong>lias</p>
    </div>

    <table>
        <thead><tr><th>Механика</th><th>Ключевой вопрос</th></tr></thead>
        <tbody>
            <tr><td><strong>Len/Cap</strong></td><td>Когда cap достаточно?</td></tr>
            <tr><td><strong>Copy-on-append</strong></td><td>Когда append создаёт новый массив?</td></tr>
            <tr><td><strong>Alias</strong></td><td>Какие слайсы делят один массив?</td></tr>
        </tbody>
    </table>

    <hr>

    <h2 id="quiz">Проверь себя</h2>

    <div class="cards">
        <div class="card question-card">
            <div class="card-head">
                <span class="card-num">01</span>
                <span class="card-title">Что такое слайс? Чем он отличается от массива?</span>
            </div>
            <div class="card-body">
                <details>
                    <summary>Показать ответ</summary>
                    <div class="answer">
                        <p>Слайс — это <strong>структура-обёртка</strong> над массивом, содержащая указатель, длину и вместимость.</p>
                        <p><strong>Отличия от массива:</strong></p>
                        <p>- Массив имеет фиксированный размер (часть типа), слайс — динамический</p>
                        <p>- Массив копируется целиком, слайс — только header (24 байта)</p>
                        <p>- Массив <code>[3]int</code> и <code>[5]int</code> — разные типы, <code>[]int</code> — один тип</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card question-card">
            <div class="card-head">
                <span class="card-num">02</span>
                <span class="card-title">Из каких трёх компонентов состоит слайс?</span>
            </div>
            <div class="card-body">
                <details>
                    <summary>Показать ответ</summary>
                    <div class="answer">
                        <p><strong>1. ptr</strong> — указатель на underlying array (адрес первого элемента)</p>
                        <p><strong>2. len</strong> — текущая длина (количество используемых элементов)</p>
                        <p><strong>3. cap</strong> — вместимость (максимальное количество без реаллокации)</p>
                        <p>Всего <strong>24 байта</strong> на 64-bit системе (8 + 8 + 8).</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card question-card">
            <div class="card-head">
                <span class="card-num">03</span>
                <span class="card-title">Почему слайс называют "ссылочным типом"?</span>
            </div>
            <div class="card-body">
                <details>
                    <summary>Показать ответ</summary>
                    <div class="answer">
                        <p>При копировании слайса копируется <strong>только header</strong>, а не данные. Оба слайса будут указывать на <strong>один и тот же underlying array</strong>.</p>
                        <p>Это значит:</p>
                        <p>- Изменения через один слайс видны через другой</p>
                        <p>- Передача слайса в функцию — дешёвая операция (24 байта)</p>
                        <p>- Нужно быть осторожным с alias'ами</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card question-card">
            <div class="card-head">
                <span class="card-num">04</span>
                <span class="card-title">Что такое underlying array?</span>
            </div>
            <div class="card-body">
                <details>
                    <summary>Показать ответ</summary>
                    <div class="answer">
                        <p>Underlying array — это <strong>обычный массив фиксированного размера в памяти</strong>, на который указывает слайс.</p>
                        <p>Особенности:</p>
                        <p>- Несколько слайсов могут указывать на один underlying array</p>
                        <p>- Когда capacity исчерпана, создаётся новый underlying array</p>
                        <p>- GC освобождает underlying array только когда на него никто не указывает</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card question-card">
            <div class="card-head">
                <span class="card-num">05</span>
                <span class="card-title">Чем отличается len от cap?</span>
            </div>
            <div class="card-body">
                <details>
                    <summary>Показать ответ</summary>
                    <div class="answer">
                        <p><strong>len</strong> — сколько элементов <strong>используется</strong> сейчас</p>
                        <p><strong>cap</strong> — сколько элементов <strong>может вместить</strong> underlying array</p>
                        <p>Всегда выполняется: <code>0 &lt;= len &lt;= cap</code></p>
                        <p>Когда <code>len == cap</code> и нужно добавить элемент — происходит <strong>реаллокация</strong>.</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card question-card">
            <div class="card-head">
                <span class="card-num">06</span>
                <span class="card-title">Что скопируется при <code>b := a</code> где <code>a</code> — слайс из 1 миллиона элементов?</span>
            </div>
            <div class="card-body">
                <details>
                    <summary>Показать ответ</summary>
                    <div class="answer">
                        <p>Скопируется <strong>только header</strong> — 24 байта (ptr, len, cap).</p>
                        <p>Данные (1 миллион элементов) <strong>НЕ копируются</strong>. И <code>a</code>, и <code>b</code> будут указывать на один underlying array.</p>
                        <p>Это эффективно, но опасно: изменения через <code>b</code> будут видны через <code>a</code>.</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card question-card">
            <div class="card-head">
                <span class="card-num">07</span>
                <span class="card-title">Почему <code>return data[:10]</code> может вызвать утечку памяти?</span>
            </div>
            <div class="card-body">
                <details>
                    <summary>Показать ответ</summary>
                    <div class="answer">
                        <p>Потому что <code>data[:10]</code> создаёт слайс, который <strong>указывает на тот же underlying array</strong> что и <code>data</code>.</p>
                        <p>Даже если <code>data</code> был 100MB, а мы возвращаем "только 10 байт" — весь 100MB массив останется в памяти.</p>
                        <p><strong>Решение:</strong> <code>copy()</code> в новый слайс нужного размера.</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card question-card">
            <div class="card-head">
                <span class="card-num">08</span>
                <span class="card-title">Что произойдёт с <code>a</code> после: <code>b := a[1:3]; b[0] = 999</code>?</span>
            </div>
            <div class="card-body">
                <details>
                    <summary>Показать ответ</summary>
                    <div class="answer">
                        <p><code>a[1]</code> станет равен 999.</p>
                        <p>Потому что <code>b</code> — это "окно" в тот же underlying array. <code>b[0]</code> и <code>a[1]</code> — это <strong>одна и та же ячейка памяти</strong>.</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card question-card">
            <div class="card-head">
                <span class="card-num">09</span>
                <span class="card-title">Как правильно создать независимую копию части слайса?</span>
            </div>
            <div class="card-body">
                <details>
                    <summary>Показать ответ</summary>
                    <div class="answer">
                        <p>Использовать <code>copy()</code>:</p>
                        <p><code>b := make([]int, 2)</code> — создаём новый underlying array</p>
                        <p><code>copy(b, a[1:3])</code> — копируем данные</p>
                        <p>Теперь <code>b</code> независим от <code>a</code>.</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card question-card">
            <div class="card-head">
                <span class="card-num">10</span>
                <span class="card-title">Когда append создаёт новый underlying array?</span>
            </div>
            <div class="card-body">
                <details>
                    <summary>Показать ответ</summary>
                    <div class="answer">
                        <p>Когда <code>len == cap</code> (нет свободного места) и нужно добавить элемент.</p>
                        <p>Go создаёт новый массив (обычно cap*2), копирует данные, добавляет новый элемент.</p>
                        <p>После реаллокации слайс указывает на <strong>новый</strong> массив.</p>
                    </div>
                </details>
            </div>
        </div>
    </div>

    <hr>

    <h2 id="practice">Практика</h2>

    <div class="cards">
        <div class="card task-card">
            <div class="card-head">
                <span class="card-num">01</span>
                <span class="card-title">Что выведет?</span>
            </div>
            <div class="card-body">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">Go</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">a := []int{1, 2, 3}
b := a
b[0] = 999
fmt.Println(a[0])</code></pre>
                </div>
                <details>
                    <summary>Показать решение</summary>
                    <div class="solution">
                        <p><strong>Вывод: 999</strong></p>
                        <p><code>b := a</code> копирует header. <code>b.ptr</code> указывает на тот же массив.</p>
                        <p><strong>Ключевой момент:</strong> <code>a</code> и <code>b</code> — alias'ы одного массива.</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card task-card">
            <div class="card-head">
                <span class="card-num">02</span>
                <span class="card-title">Что выведет?</span>
            </div>
            <div class="card-body">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">Go</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">func change(s []int) {
    s = append(s, 4)
    s[0] = 999
}

a := []int{1, 2, 3}
change(a)
fmt.Println(a)</code></pre>
                </div>
                <details>
                    <summary>Показать решение</summary>
                    <div class="solution">
                        <p><strong>Вывод: [1 2 3]</strong></p>
                        <p>1. <code>a</code> имеет len=3, cap=3 (нет места для 4-го элемента)</p>
                        <p>2. <code>change(a)</code> — передаётся <strong>копия header</strong></p>
                        <p>3. <code>s = append(s, 4)</code> — cap исчерпан, <strong>реаллокация!</strong></p>
                        <p>4. <code>s</code> теперь указывает на <strong>новый</strong> массив</p>
                        <p>5. <code>s[0] = 999</code> — меняет новый массив</p>
                        <p>6. <code>a</code> по-прежнему указывает на старый [1, 2, 3]</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card task-card">
            <div class="card-head">
                <span class="card-num">03</span>
                <span class="card-title">Найди утечку памяти</span>
            </div>
            <div class="card-body">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">Go</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">func getFirstTen(filename string) []byte {
    data, _ := os.ReadFile(filename)  // файл 100MB
    return data[:10]
}</code></pre>
                </div>
                <details>
                    <summary>Показать решение</summary>
                    <div class="solution">
                        <p><strong>Проблема:</strong> <code>data[:10]</code> создаёт слайс с <code>cap = 100MB</code>.</p>
                        <p>GC не может освободить 100MB массив, пока на него есть хоть одна ссылка.</p>
                        <p><strong>Исправление:</strong></p>
                        <p><code>result := make([]byte, 10)</code></p>
                        <p><code>copy(result, data[:10])</code></p>
                        <p><code>return result</code></p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card task-card">
            <div class="card-head">
                <span class="card-num">04</span>
                <span class="card-title">Что выведет?</span>
            </div>
            <div class="card-body">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">Go</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">a := make([]int, 3, 5)
a[0], a[1], a[2] = 1, 2, 3

b := a[1:3]
fmt.Println(len(b), cap(b))</code></pre>
                </div>
                <details>
                    <summary>Показать решение</summary>
                    <div class="solution">
                        <p><strong>Вывод: 2 4</strong></p>
                        <p>1. <code>a := make([]int, 3, 5)</code> - underlying array [1,2,3,_,_], len=3, cap=5</p>
                        <p>2. <code>b := a[1:3]</code> - b "смотрит" на элементы a[1] и a[2]</p>
                        <p>3. <code>len(b) = 3 - 1 = 2</code> (два элемента: a[1] и a[2])</p>
                        <p>4. <code>cap(b) = cap(a) - 1 = 5 - 1 = 4</code> (от a[1] до конца)</p>
                        <p><strong>Формула:</strong> при <code>b := a[low:high]</code>:</p>
                        <p>- <code>len(b) = high - low</code></p>
                        <p>- <code>cap(b) = cap(a) - low</code></p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card task-card">
            <div class="card-head">
                <span class="card-num">05</span>
                <span class="card-title">Оптимизируй код</span>
            </div>
            <div class="card-body">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">Go</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">func collectEven(n int) []int {
    var result []int
    for i := 0; i <= n; i++ {
        if i%2 == 0 {
            result = append(result, i)
        }
    }
    return result
}</code></pre>
                </div>
                <details>
                    <summary>Показать решение</summary>
                    <div class="solution">
                        <p><strong>Проблема:</strong> Множественные реаллокации при росте слайса.</p>
                        <p>Если n=1000, слайс будет расти: 1-2-4-8-16-...-512 — около 10 реаллокаций!</p>
                        <p><strong>Оптимизация — pre-allocate:</strong></p>
                        <p><code>count := n/2 + 1</code></p>
                        <p><code>result := make([]int, 0, count)</code></p>
                        <p>Теперь <strong>0 реаллокаций</strong> — память выделена сразу.</p>
                    </div>
                </details>
            </div>
        </div>

        <div class="card task-card">
            <div class="card-head">
                <span class="card-num">06</span>
                <span class="card-title">Что выведет?</span>
            </div>
            <div class="card-body">
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">Go</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-go">a := make([]int, 3, 6)
a[0], a[1], a[2] = 1, 2, 3

b := a[1:3]
b = append(b, 4)

fmt.Println(a)
fmt.Println(b)</code></pre>
                </div>
                <details>
                    <summary>Показать решение</summary>
                    <div class="solution">
                        <p><strong>Вывод:</strong></p>
                        <p><code>[1 2 3]</code></p>
                        <p><code>[2 3 4]</code></p>
                        <p><strong>Разбор:</strong></p>
                        <p>1. <code>a</code> = [1, 2, 3, _, _, _] (len=3, cap=6)</p>
                        <p>2. <code>b := a[1:3]</code> = [2, 3] (len=2, cap=5) — указывает на a[1]</p>
                        <p>3. <code>b = append(b, 4)</code> — cap(b)=5, есть место! Реаллокации нет.</p>
                        <p>4. Элемент 4 записывается в <code>a[3]</code> (следующая позиция)</p>
                        <p>5. Но <code>len(a)</code> всё ещё 3, поэтому <code>a</code> выводит [1, 2, 3]</p>
                        <p><strong>Ключевой момент:</strong> append записал 4 в a[3], но a.len не изменился!</p>
                    </div>
                </details>
            </div>
        </div>
    </div>

    <hr>

    <h2 id="summary">Резюме</h2>

    <div class="summary-box">
        <div class="summary-header">
            <span class="summary-badge">Key</span>
            <span class="summary-title">Ключевое правило</span>
        </div>
        <div class="summary-formula">СЛАЙС = ptr + len + cap (24 байта)</div>
        <ul class="summary-list">
            <li>Слайс — "окно" в underlying array</li>
            <li>При копировании копируется header, <strong>НЕ</strong> данные</li>
            <li>Изменения через копию видны в оригинале (alias!)</li>
            <li>Reslicing <code>a[i:j]</code> создаёт alias на тот же массив</li>
            <li>append может создать <strong>НОВЫЙ</strong> массив (реаллокация)</li>
            <li>Для изоляции используй <code>copy()</code></li>
            <li>Pre-allocate с <code>make([]T, 0, size)</code> для производительности</li>
        </ul>
    </div>

    <nav class="nav-footer">
        <a href="#" class="nav-link next">
            <div>
                <div class="nav-label">Следующий</div>
                <div class="nav-title">Как работает append</div>
            </div>
            <span class="nav-arrow">&rarr;</span>
        </a>
    </nav>
</main>

<script>
    // Initialize Telegram WebApp
    const tg = window.Telegram?.WebApp;

    if (tg) {
        // Signal that app is ready
        tg.ready();

        // Expand to full height
        tg.expand();

        // Force dark theme - ignore Telegram theme

        // Show back button (would navigate to lesson list in full app)
        tg.BackButton.show();
        tg.BackButton.onClick(() => {
            // In demo - just show alert
            tg.showAlert('В полной версии здесь будет список уроков');
        });
    }

    // Highlight.js init
    hljs.highlightAll();

    // Copy code function
    function copyCode(btn) {
        const code = btn.closest('.code-block').querySelector('code');
        const text = code.textContent;

        // Try clipboard API first
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(() => {
                showCopied(btn);
            }).catch(() => {
                fallbackCopy(text, btn);
            });
        } else {
            fallbackCopy(text, btn);
        }
    }

    function fallbackCopy(text, btn) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        try {
            document.execCommand('copy');
            showCopied(btn);
        } catch (e) {
            if (tg) {
                tg.showAlert('Не удалось скопировать');
            }
        }
        document.body.removeChild(textarea);
    }

    function showCopied(btn) {
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => {
            btn.textContent = 'Copy';
            btn.classList.remove('copied');
        }, 2000);
    }
</script>

</body>
</html>
